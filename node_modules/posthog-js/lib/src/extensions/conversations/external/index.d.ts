import { ConversationsRemoteConfig, UserProvidedTraits, SendMessageResponse, GetMessagesResponse, MarkAsReadResponse, GetTicketsOptions, GetTicketsResponse } from '../../../posthog-conversations-types';
import { PostHog } from '../../../posthog-core';
import { ConversationsManager as ConversationsManagerInterface } from '../posthog-conversations';
export declare class ConversationsManager implements ConversationsManagerInterface {
    private readonly _posthog;
    private _config;
    private _persistence;
    private _widgetRef;
    private _containerElement;
    private _currentTicketId;
    private _pollIntervalId;
    private _lastMessageTimestamp;
    private _isPolling;
    private _unsubscribeIdentifyListener;
    private _unreadCount;
    private _widgetSessionId;
    private _isWidgetEnabled;
    private _isDomainAllowed;
    private _isWidgetRendered;
    constructor(config: ConversationsRemoteConfig, _posthog: PostHog);
    /**
     * Send a message programmatically via the API
     * Creates a new ticket if none exists or if newTicket is true
     *
     * @param message - The message text to send
     * @param userTraits - Optional user identification data (name, email)
     * @param newTicket - If true, forces creation of a new ticket (ignores current ticket)
     * @returns Promise with the response including ticket_id and message_id
     */
    sendMessage(message: string, userTraits?: UserProvidedTraits, newTicket?: boolean): Promise<SendMessageResponse>;
    /**
     * Switch to a different ticket if an explicit ticketId is provided
     * This ensures subsequent operations (sendMessage, etc.) use the correct ticket
     */
    private _switchToTicketIfNeeded;
    /** Fetch messages via the API */
    getMessages(ticketId?: string, after?: string): Promise<GetMessagesResponse>;
    /** Mark messages as read via the API */
    markAsRead(ticketId?: string): Promise<MarkAsReadResponse>;
    /**
     * Initialize the conversations manager.
     * Always initializes persistence and event listeners for API usage.
     * Only renders the widget if widgetEnabled is true AND domain is allowed.
     */
    private _initialize;
    /**
     * Initialize and render the widget UI
     */
    private _initializeWidget;
    /**
     * Get initial user traits from PostHog or localStorage
     */
    private _getInitialUserTraits;
    /**
     * Handle user identification from the widget form
     */
    private _handleIdentify;
    /**
     * Handle sending a message from the widget
     */
    private _handleSendMessage;
    /**
     * Handle widget state changes
     */
    private _handleStateChange;
    /**
     * Mark messages as read
     */
    private _markMessagesAsRead;
    /**
     * Load messages for the current ticket
     */
    private _loadMessages;
    /**
     * Check if the widget is currently open
     */
    private _isWidgetOpen;
    /**
     * Poll for new messages
     */
    private _pollMessages;
    /**
     * Start polling for new messages
     */
    private _startPolling;
    /**
     * Stop polling for new messages
     */
    private _stopPolling;
    /**
     * Setup listener for identify events to handle distinct_id changes
     */
    private _setupIdentifyListener;
    /**
     * Handle distinct_id changes when user identifies.
     * The user continues their conversation seamlessly - widget_session_id stays the same.
     * No migration needed since tickets are keyed by widget_session_id, not distinct_id.
     * Backend will update ticket.distinct_id for Person linking on the next message.
     */
    private _handleDistinctIdChange;
    /**
     * Show the widget (render it to DOM).
     * The widget respects its saved state (open/closed).
     * Note: Domain restrictions still apply - widget won't render on disallowed domains.
     */
    show(): void;
    /**
     * Hide and remove the widget from the DOM.
     * Conversation data is preserved - call show() to re-render.
     */
    hide(): void;
    /**
     * Check if the widget is currently visible (rendered in DOM)
     */
    isVisible(): boolean;
    /** Get tickets list for the current widget session */
    getTickets(options?: GetTicketsOptions): Promise<GetTicketsResponse>;
    /**
     * Get the current active ticket ID
     * Returns null if no conversation has been started yet
     */
    getCurrentTicketId(): string | null;
    /**
     * Get the widget session ID (persistent browser identifier)
     * This ID is used for access control and stays the same across page loads
     */
    getWidgetSessionId(): string;
    /**
     * Clean up the widget
     */
    destroy(): void;
    /**
     * Reset all conversation data and destroy the widget.
     * Called on posthog.reset() to start fresh.
     */
    reset(): void;
    /**
     * Render the widget to the DOM
     */
    private _renderWidget;
}
/**
 * Initialize the conversations widget
 * This is the entry point called from the lazy-loaded bundle
 */
export declare function initConversations(config: ConversationsRemoteConfig, posthog: PostHog): ConversationsManager;
